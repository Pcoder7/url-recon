name: Url recon from waybackarchive & filtering

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  generate_matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set_matrix.outputs.matrix }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Generate Matrix from domains.txt
        id: set_matrix
        run: |
          if [ ! -f domains.txt ]; then
            echo "domains.txt file not found!"
            exit 1
          fi
          # Create a JSON array from non-empty lines in domains.txt
          matrix=$(jq -R -s -c 'split("\n") | map(select(length > 0))' domains.txt)
          echo "Matrix: $matrix"
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

  scan:
    needs: generate_matrix
    runs-on: ubuntu-latest
    strategy:
      matrix:
        domain: ${{ fromJson(needs.generate_matrix.outputs.matrix) }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
      
      - name: Update & Install Dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y curl git jq unzip

      - name: Create Results Directory for ${{ matrix.domain }}
        run: |
           mkdir -p results/${{ matrix.domain }}
           rm -f results/${{ matrix.domain }}/urls/*.txt || true
             
          
      - name: URL Enumeration for ${{ matrix.domain }}
        run: |
            DOMAIN="${{ matrix.domain }}"
            OUTDIR="results/${DOMAIN}/urls"
            mkdir -p "$OUTDIR"
            BLACKLIST_EXT=".css,.ico,.jpg,.jpeg,.png,.bmp,.svg,.img,.gif,.mp4,.flv,.ogv,.webm,.webp,.mov,.mp3,.m4a,.m4p,.scss,.tif,.tiff,.ttf,.otf,.woff,.woff2,.bmp,.ico,.eot,.htc,.rtf,.swf,.image"
      
            # Install URL enumeration tools
            go install github.com/tomnomnom/waybackurls@latest
            go install github.com/lc/gau/v2/cmd/gau@latest
            pip install waymore
            pip install urless
            pipx install uro
      
            # 1. Waybackurls: archived URLs
            waybackurls "$DOMAIN" > "$OUTDIR/waybackurls.txt"
      
            # 2. gau: combined source URLs, filter out images
            gau --subs --blacklist "$BLACKLIST_EXT" --providers wayback,commoncrawl,otx --o "$OUTDIR/gau.txt" "$DOMAIN"
      
            # 3. waymore: deep crawl with archive mode U
            waymore -i "$DOMAIN" -mode U -oU "$OUTDIR/waymore.txt"
      
            # 4. Combine and dedupe all URL lists
            cat "$OUTDIR/waybackurls.txt" "$OUTDIR/gau.txt" "$OUTDIR/waymore.txt" \
                | sort -u > "$OUTDIR/all_urls.txt"
             
             # count all urls
            cat "$OUTDIR/all_urls.txt" | wc -l
      
            # 5. Filter image and js extensions, then select only URLs with parameters
            cat "$OUTDIR/all_urls.txt" \
                | uro --filters hasparams -b "$BLACKLIST_EXT" -o "$OUTDIR/parameterized_urls.txt"
                
           
               # 6. Further clean with urless (drop blogs, JS libs, etc.) 
            cat "$OUTDIR/parameterized_urls.txt" \
                | urless -nb -fk blog,article,news,bootstrap,jquery,captcha,node_modules -o "$OUTDIR/all_filtered.txt"    

              # count all filtered urls
            cat "$OUTDIR/all_filtered.txt" | wc -l

      # â”€â”€â”€ Install gf & pattern files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Install gf and Gf-Patterns
        run: |
          # install gf CLI
          go install github.com/tomnomnom/gf@latest
          # pull down community JSONs
          git clone https://github.com/1ndianl33t/Gf-Patterns.git
          # prepare your ~/.gf dir and copy examples
          mkdir -p ~/.gf
          mv Gf-Patterns/*.json ~/.gf
          # expose GF_PATH if needed
          echo "GF_PATH=$HOME/.gf" >> $GITHUB_ENV

      
      # Compare & Alert on New URLs
      - name: Compare & Alert on New URLs for ${{ matrix.domain }}
        id: compare_urls
        run: |
            NEW="results/${{ matrix.domain }}/urls/all_filtered.txt"
            OLD=$(mktemp)
            git show HEAD:$NEW 2>/dev/null | sort -u > "$OLD" || touch "$OLD"
            sort -u "$NEW" > "${NEW}.sorted"
            comm -23 "${NEW}.sorted" "$OLD" > results/${{ matrix.domain }}/urls/new_urls.txt
            if [ -s results/${{ matrix.domain }}/urls/new_urls.txt ]; then
              echo "has_new_urls=true" >> $GITHUB_OUTPUT
            else
              echo "has_new_urls=false" >> $GITHUB_OUTPUT
            fi

      # â”€â”€â”€ Extract vulnerability parameters via gf â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Extract SSRF, sqli, lfi, debug_logic & idor parameters
        run: |
          DOMAIN="${{ matrix.domain }}"
          BASE="results/${{ matrix.domain }}/urls"
          INPUT="$BASE/new_urls.txt"

          # produce one file per pattern
          cat "$INPUT" | gf ssrf          > "$BASE/ssrf_params.txt"
          cat "$INPUT" | gf sqli          > "$BASE/sqli_params.txt"
          cat "$INPUT" | gf lfi           > "$BASE/lfi_params.txt"
          cat "$INPUT" | gf debug_logic   > "$BASE/debug_logic_params.txt"
          cat "$INPUT" | gf idor          > "$BASE/idor_params.txt"      
     
      - name: Install notify
        env: 
          DISCORD_WEBHOOK: ${{ secrets.URLRECON_WEBHOOK }}
        run: |
          go install -v github.com/projectdiscovery/notify/cmd/notify@latest
          mkdir -p ~/.config/notify/
          cat <<EOF > ~/.config/notify/provider-config.yaml
              # Write provider config with our Discord webhook
          discord:
            - id: "fuzz"
              discord_channel: "subdomain-scan"
              discord_format: "{{data}}"
              discord_webhook_url: "${{ secrets.URLRECON_WEBHOOK }}"
          EOF
          echo "$HOME/go/bin" >> $GITHUB_PATH
          # display and show provider-config.yaml file
          cat ~/.config/notify/provider-config.yaml  

      - name: Show notify config
        run: | 
          echo "$URLRECON_WEBHOOK"
          sed -e 's/.*/&/' ~/.config/notify/provider-config.yaml
        env:
          DISCORD_WEBHOOK: ${{ secrets.URLRECON_WEBHOOK }}
          
            #  Notify Discord for each pattern if there are findings
      - name: Notify Discord vulnerability params for ${{ matrix.domain }}
        env:
          DISCORD_WEBHOOK: ${{ secrets.URLRECON_WEBHOOK }}
        run: |
          DOMAIN="${{ matrix.domain }}"
          DATE=$(date +"%d-%m-%Y")
          BASE="results/${DOMAIN}/urls"

           # loop over each pattern's file
          for PAT in ssrf sqli lfi debug_logic idor; do
            FILE="$BASE/${PAT}_params.txt"
            if [ -s "$FILE" ]; then
              # header for this pattern
              echo -e "ðŸ”” New ${PAT^^} parameters for ${DOMAIN}\nðŸ“… Date: ${DATE}" \
                | notify -id fuzz
              # attach the findings file
              notify -bulk -id fuzz -data "$FILE" -char-limit 1000000 -no-color
            fi
          done
      
      - name: Notify Discord of New URLs for ${{ matrix.domain }}
        if: steps.compare_urls.outputs.has_new_urls == 'true'
        run: |
            DOMAIN="${{ matrix.domain }}"
            DATE=$(date +"%d-%m-%Y")
            FILE="results/${DOMAIN}/urls/new_urls.txt"
            COUNT=$(wc -l < "$FILE")
      
            # Send file if >50, else one bulk message
            if [ "$COUNT" -gt 50 ]; then
              # header message
              echo -e "ðŸ”” New URLs for ${{ matrix.domain }}\nðŸ“… Date: $DATE" \
                | notify -id fuzz
              # file attachment
              notify -bulk -id fuzz -data "$FILE" -char-limit 1000000 -no-color
            else
              # bulk message
              {
                echo "ðŸ”” New URLs for ${{ matrix.domain }}"
                echo "ðŸ“… Date: $DATE"
                echo
                cat "$FILE"
              } | notify -bulk -id fuzz
            fi


